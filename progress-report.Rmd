---
title: "Project2-DataScience"
author: "Abanoub Mimi, Amir George, Tony Foti"
date: "May 8, 2016"
output: html_document
---

#Exploratory analysis (Amir)
We begin by attaching required libraries and loading the datasets and relevant classifiers.
```{r message=FALSE}
library(dplyr)
library(knitr)
library(RWeka)
library(tidyr)
library(ggplot2)
```
```{r cache=TRUE}
trainDf <- read.csv('data/train.csv')
testDf <- read.csv('data/test.csv')
contractRefDf <- read.csv('data/contract_ref.csv')
calendarRefDf <- read.csv('data/calendar_ref.csv')
dailyAggDf <- read.csv('data/daily_aggregate.csv')
roamingDf <- read.csv('data/roaming_monthly.csv')
```
```{r}
trainDf$TARGET <- as.factor(trainDf$TARGET)
RF <- make_Weka_classifier("weka/classifiers/trees/RandomForest")
NB <- make_Weka_classifier("weka/classifiers/bayes/NaiveBayes")
MLP <- make_Weka_classifier("weka/classifiers/functions/MultilayerPerceptron")
```
## Train and Test datasets
We proceed by taking a look at the training and test datasets:
```{r}
trainDf %>% dim
trainDf$CONTRACT_KEY %>% unique %>% length
trainDf %>% summary
sapply(trainDf, function(x) sum(is.na(x)))
testDf %>% dim
testDf$CONTRACT_KEY %>% unique %>% length
testDf %>% summary
sapply(testDf, function(x) sum(is.na(x)))
```
There are no NA values in the original train and test datasets, and no multiple observations for the same `CONTRACT_KEY`.

## ContractRef dataset
We now proceed with examiming the `contract_ref` dataset.
```{r}
contractRefDf %>% dim
contractRefDf$CONTRACT_KEY %>% unique %>% length
```
No multiple observations for the same `CONTRACT_KEY`.
```{r}
sapply(contractRefDf, function(x) sum(is.na(x)))
contractRefDf %>% summary
```
Some weird observations are spotted in this examination:
### Unnaturally small age values
```{r}
contractRefDf[contractRefDf$AGE < 15,]
```
There are 5 observations with a negative age, which is impossible. Also, there are 7 observations with suspiciously small ages ranging from 1 to 4 years.

### Age values of `99`
```{r}
contractRefDf[contractRefDf$AGE == 99,] %>% nrow
```
Almost half the observations in this dataset (51263 out of 107743) have an age value of `99`, which could be a default value for unknown or not entered ages.

###Incomplete `GENDER` observations
More than half the oservations (54379 out of 107743) have missing gender values labeled as `Not Entered`, while 3148 observations have gender values labeled as `Unknown`.
```{r}
length(intersect(unique(trainDf$CONTRACT_KEY),unique(contractRefDf[contractRefDf$GENDER == "Not Entered",]$CONTRACT_KEY)))
length(intersect(unique(testDf$CONTRACT_KEY),unique(contractRefDf[contractRefDf$GENDER == "Not Entered",]$CONTRACT_KEY)))
```
The missing observations are not tied to customers of train dataset only or test dataset only as shown above.
```{r}
contractRefDf$GENDER %>% unique
```
Moreover, the male gender has multiple labels (`Male`, `M` & `m`), as well as the female gender (`Female`, `F` & `f`).

###NAs in `VALUE_SEGMENT`
There are 6 NA observations in the `VALUE_SEGMENT` column, as well as 8169 values of "N/A" which are basically the same as NA values. So, these are all missing values.

##Roaming dataset
```{r}
roamingDf %>% dim
roamingDf$CONTRACT_KEY %>% unique %>% length
roamingDf %>% summary
sapply(roamingDf, function(x) sum(is.na(x)))
```
No weird observations here. The number of observations is greater than the number of unique customers because each customer can have multiple entries concerning different months.

##CalendarRef dataset
```{r}
calendarRefDf %>% dim
calendarRefDf$DATE_KEY %>% unique %>% length
calendarRefDf %>% summary
sapply(calendarRefDf, function(x) sum(is.na(x)))
```
An interesting observation here is that there are 183 different dates although we only need 29 dates representing the last month in our data which is February 2016.

##Daily aggregate dataset
```{r cache=TRUE}
dailyAggDf %>% dim
dailyAggDf$CONTRACT_KEY %>% unique %>% length
length(intersect(unique(trainDf$CONTRACT_KEY),unique(dailyAggDf$CONTRACT_KEY)))
length(intersect(unique(testDf$CONTRACT_KEY),unique(dailyAggDf$CONTRACT_KEY)))
dailyAggDf %>% summary
sapply(dailyAggDf, function(x) sum(is.na(x)))
```
The daily aggregate dataframe has 4985457 observations that belong to 30995 different customers. Out of those customers, 21708 reside in the training dataset while the remaining 9287 reside in the testing dataset.
```{r}
calendarRefDf[calendarRefDf$DATE_KEY==6337,]
calendarRefDf[calendarRefDf$DATE_KEY==6365,]
```
The min and max date keys correspond to the first and last days of February 2016 respectively. This indicates that the date keys are relatively ordered with respect to the dates.  
Now we proceed to validate the observations in the daily aggregate dataset with what we already know from the monthly datasets. We randomly choose user with `CONTRACT_KEY`=`150761380` to study on.
```{r}
trainDf[trainDf$CONTRACT_KEY==150761380,c("X210_USAGE", "X210_SESSION_COUNT")]
dailyAggDf[dailyAggDf$CONTRACT_KEY==150761380,]$NO_OF_SESSIONS %>% sum
```
We find that the sum of number of sessions of all days is indeed the total number of sessions in the last month.
```{r}
dailyAggDf[dailyAggDf$CONTRACT_KEY==150761380,]$TOTAL_CONSUMPTION %>% sum
```
However, the sum of total consumption all days does not match the monthly usage value. If we divide the sum by (1024 * 1024) and round up we get a matching value. 
```{r}
735391744 / (1024 * 1024)
```
This indicates that the daily consumption was in bytes and what we did now was converting it to MB.

#Offline Evaluation
Due to the limited number of possible submissions per day on the kaggle competition, a method for offline evaluation of our obtained models was necessary. Two helper functions serve that purpose. The function `getEvaluation` extracts the required classification evaluation measures from a given confusion matrix.
```{r}
getEvaluation <- function(confMat) {
  tp <- confMat[1,1]
  fn <- confMat[1, 2]
  fp <- confMat[2, 1]
  tn <- confMat[2, 2]
  Accurary <- (tp + tn) / (tp + fn + fp + tn)
  Precision <- tp / (tp + fp)
  Recall <- tp / (tp + fn)
  F1 <- (2 * Precision * Recall) / (Precision + Recall)
  res <- cbind(Accurary,Precision,Recall,F1)
  return(res)
}
```
The function `evaluateModel` uses stratified 10-fold cross-validation to evaluate the input model, and calls the `getEvaluation` function to obtain the relevant scores, then outputs them.
```{r}
evaluateModel <- function(model){
  tenFoldModel <- evaluate_Weka_classifier(model, numFolds = 10, seed = 123)
  tenFoldModel$confusionMatrix %>% getEvaluation %>% kable
}
```


#Progress tracking
In the following subsections we present a brief description of several approaches we tried in order to increase the score. Each subsection denotes the person who carried out its approach, and related files to this approach (whether they are scripts, output files or workspace images) can be found in a folder inside the `scripts` folder with the following naming convention: `Number-Implementer-Score`. The code chunks embedded in this section are for illustration purposes only.

##4- Decisioon Tree with merging all `contract_ref.csv` columns (Amir)
By continuing on number `1` above (Decision Tree classifier), I merged with all columns from `contract_ref.csv`, and obtained a score of `0.57585`, which is a decrease from the original score, so this approach was neglected.

##5- Naive Bayes classifier (Amir)
By trying on on the Naive Bayes classifier, a score of `0.56603` was obtained, which was less than that obtained from the Decision Tree classifier, so this approach was neglected.

##6- Support Vector Machine classifier (Amir)
By trying on on the Support Vector Machine (SMO) classifier, a score of `0.50000` was obtained, which was less than that obtained from the Decision Tree classifier, so this approach was neglected.

##9- Neural Network with removing `SESSION_COUNT` columns (Amir)
By continuing on number `8` above (NN classifier), I removed all `SESSION_COUNT` from the prediction. The intuition behind this approach is that `USAGE` is the main concern here. However, a decreased score of `0.58118` was obtained, proving that session count indeed matters, and the approach here was neglected.

##10- Neural Network with weighted monthly usages (Amir)
By continuing on number `8` above (NN classifier), an approach was tried to weigh all monthly usages. The intuition was that the last month would be the most important month, followed by the second to last month and so on. This was implemented by multiplying the usage columns in the last 4 months by values ranging from 2 to 5.
```{r eval=FALSE}
trainDf <- trainDf %>% mutate(X207_USAGE=X207_USAGE*2, X208_USAGE=X208_USAGE*3, 
                             X209_USAGE=X209_USAGE*4,X210_USAGE=X210_USAGE*5)
testDf <- testDf %>% mutate(X207_USAGE=X207_USAGE*2, X208_USAGE=X208_USAGE*3, 
                             X209_USAGE=X209_USAGE*4,X210_USAGE=X210_USAGE*5)
```
A low score of `0.50587` was obtained as a result, so this approach was neglected. I suspect that the intuition itself could be sound but the way in which it was implemented was responsible for the decreased score.

##11- Neural Network with only last month data (Amir)
By continuing on number `8` above (NN classifier), an approach was tried to only depend on the data from the last month, and neglect all the usage and session count columns from the first four months.
```{r eval=FALSE}
trainKeeps <- c("CONTRACT_KEY","X210_SESSION_COUNT","X210_USAGE","TARGET")
trainDf <- trainDf[trainKeeps]
testKeeps <- c("CONTRACT_KEY","X210_SESSION_COUNT","X210_USAGE")
testDf <- testDf[testKeeps]
```
A score of `0.62686` was obtained which is surprisingly not much less than the original score of `0.63391`. But due to it being a lesser score, the approach was neglected.

##12- Neural Network with removing `CONTRACT_KEY` from predictions (Amir)
I realized that the `CONTRACT_KEY` in both the train and test datasets factored as an integer in the predictions, which does not make sense at all. So, by removing it from predictions, an improved score of `0.65550` was obtained with the NN classifier. So, this approach is taken into account from now on.

##13- Feature extraction to integrating roaming data (Amir)
Buidling on the approach in `12`, I integrated with the roaming data from the `roaming_monthly.csv` file. For both the train and test datasets, 10 extra features were added as the roaming usage and roaming number of sessions for each of the 5 months. The values of these columns were extracted from `roaming_monthly.csv`.
``` {r eval = FALSE}
trainRoamDf <- trainDf
trainRoamDf[,"R206_USAGE"] <- 0
trainRoamDf[,"R206_SESSION_COUNT"] <- 0
trainRoamDf[,"R207_USAGE"] <- 0
trainRoamDf[,"R207_SESSION_COUNT"] <- 0
trainRoamDf[,"R208_USAGE"] <- 0
trainRoamDf[,"R208_SESSION_COUNT"] <- 0
trainRoamDf[,"R209_USAGE"] <- 0
trainRoamDf[,"R209_SESSION_COUNT"] <- 0
trainRoamDf[,"R210_USAGE"] <- 0
trainRoamDf[,"R210_SESSION_COUNT"] <- 0

testRoamDf <- testDf
testRoamDf[,"R206_USAGE"] <- 0
testRoamDf[,"R206_SESSION_COUNT"] <- 0
testRoamDf[,"R207_USAGE"] <- 0
testRoamDf[,"R207_SESSION_COUNT"] <- 0
testRoamDf[,"R208_USAGE"] <- 0
testRoamDf[,"R208_SESSION_COUNT"] <- 0
testRoamDf[,"R209_USAGE"] <- 0
testRoamDf[,"R209_SESSION_COUNT"] <- 0
testRoamDf[,"R210_USAGE"] <- 0
testRoamDf[,"R210_SESSION_COUNT"] <- 0

for (k in unique(roamingDf$CONTRACT_KEY)) {
  orig <- roamingDf[roamingDf$CONTRACT_KEY==k,]
  if (trainRoamDf[trainRoamDf$CONTRACT_KEY==k,] %>% nrow > 0) {
    val <- orig[orig$CALL_MONTH_KEY == 206,]
    if (nrow(val) > 0) {
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R206_USAGE"] = val$USAGE
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R206_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- orig[orig$CALL_MONTH_KEY == 207,]
    if (nrow(val) > 0) {
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R207_USAGE"] = val$USAGE
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R207_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- orig[orig$CALL_MONTH_KEY == 208,]
    if (nrow(val) > 0) {
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R208_USAGE"] = val$USAGE
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R208_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- val[val$CALL_MONTH_KEY == 209,]
    if (nrow(val) > 0) {
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R209_USAGE"] = val$USAGE
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R209_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- orig[orig$CALL_MONTH_KEY == 210,]
    if (nrow(val) > 0) {
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R210_USAGE"] = val$USAGE
      trainRoamDf[trainRoamDf$CONTRACT_KEY==k,"R210_SESSION_COUNT"] = val$SESSION_COUNT
    }
  }
  else {
    val <- orig[orig$CALL_MONTH_KEY == 206,]
    if (nrow(val) > 0) {
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R206_USAGE"] = val$USAGE
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R206_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- orig[orig$CALL_MONTH_KEY == 207,]
    if (nrow(val) > 0) {
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R207_USAGE"] = val$USAGE
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R207_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- orig[orig$CALL_MONTH_KEY == 208,]
    if (nrow(val) > 0) {
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R208_USAGE"] = val$USAGE
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R208_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- val[val$CALL_MONTH_KEY == 209,]
    if (nrow(val) > 0) {
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R209_USAGE"] = val$USAGE
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R209_SESSION_COUNT"] = val$SESSION_COUNT
    }
    val <- orig[orig$CALL_MONTH_KEY == 210,]
    if (nrow(val) > 0) {
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R210_USAGE"] = val$USAGE
      testRoamDf[testRoamDf$CONTRACT_KEY==k,"R210_SESSION_COUNT"] = val$SESSION_COUNT
    }
  }
}
```
By factoring them into the prediction, an improved score of `0.67939` was reached. So, this approach is implemented from now on.

##14- Adjustment to roaming data (Amir)
Buidling on the approach in `13`, I implemented a small adjustment by subtracting the newly added monthly roaming data from original total mothly data, so that the original usage and session count columns would now describe local data only. 
```{r eval=FALSE}
trainRoamDf <- trainRoamDf %>% mutate(X206_SESSION_COUNT = X206_SESSION_COUNT - R206_SESSION_COUNT,
                                      X206_USAGE = X206_USAGE - R206_USAGE,
                                      X207_SESSION_COUNT = X207_SESSION_COUNT - R207_SESSION_COUNT,
                                      X207_USAGE = X207_USAGE - R207_USAGE,
                                      X208_SESSION_COUNT = X208_SESSION_COUNT - R208_SESSION_COUNT,
                                      X208_USAGE = X208_USAGE - R208_USAGE,
                                      X209_SESSION_COUNT = X209_SESSION_COUNT - R209_SESSION_COUNT,
                                      X209_USAGE = X209_USAGE - R209_USAGE,
                                      X210_SESSION_COUNT = X210_SESSION_COUNT - R210_SESSION_COUNT,
                                      X210_USAGE = X210_USAGE - R210_USAGE)

testRoamDf <- testRoamDf %>% mutate(X206_SESSION_COUNT = X206_SESSION_COUNT - R206_SESSION_COUNT,
                                      X206_USAGE = X206_USAGE - R206_USAGE,
                                      X207_SESSION_COUNT = X207_SESSION_COUNT - R207_SESSION_COUNT,
                                      X207_USAGE = X207_USAGE - R207_USAGE,
                                      X208_SESSION_COUNT = X208_SESSION_COUNT - R208_SESSION_COUNT,
                                      X208_USAGE = X208_USAGE - R208_USAGE,
                                      X209_SESSION_COUNT = X209_SESSION_COUNT - R209_SESSION_COUNT,
                                      X209_USAGE = X209_USAGE - R209_USAGE,
                                      X210_SESSION_COUNT = X210_SESSION_COUNT - R210_SESSION_COUNT,
                                      X210_USAGE = X210_USAGE - R210_USAGE)
```
The score improved to `0.68188` which makes sense. So, this approach is implemented from now on.

##15- Adding `RATE_PLAN` feature (Amir)
Building on `14`, I added the `RATE_PLAN` feature from `contract_ref` in the model prediction. Building this model took several hours on my local machine, which was expected due to the large number of levels for this feature (183 levels). However, this largely sabotaged the prediction process as a minimum score of `0.50000` resulted from this approach. This indicated that some feature engineering needs to be done on this feature and all features in `contract_ref` in general to obtain more useful parameters.

##16- Adaboosting with NN as base classifier (Amir)
Buidling on `14`, instead of using NN base classifier, I used boosting with `AdaboostM1` and with NN as its base classifier. Surprisingly, I obtained a score of `0.67495` which is less than the one obtained with the base classifier only.

##17- Analysing the `GENDER` from `contract_ref` and adding it to the predictions (Tony)
Let's check all the possible values that exist:
```{r}
contractRefDf$GENDER %>% unique
```
As we can see, we have 3 different values representing a "Female" gender ("f", "F" and "Female"). Also for the "Male" gender we have 3 different values for it ("m", "M" and "Male"). There are also 2 other values representing a gender not entered (or unknown), which reflects the same meaning ("Not Entered" and "Unknown").
We shall combine them into their corresponding 3 main categories ("Female", "Male" and "Unknown").
```{r}
contractRefDf$GENDER[contractRefDf$GENDER == "f"] <- "Female"
contractRefDf$GENDER[contractRefDf$GENDER == "F"] <- "Female"
contractRefDf$GENDER[contractRefDf$GENDER == "m"] <- "Male"
contractRefDf$GENDER[contractRefDf$GENDER == "M"] <- "Male"
contractRefDf$GENDER[contractRefDf$GENDER == "Not Entered"] <- "Unknown"
```
So adding the `GENDER` to the predicitions after the above modifications, we get a score of `0.66270` (less than the last state before adding the `GENDER` to the predictions).

##18- Analysing and extracting new features from `RATE_PLAN` and adding it to the predictions - Trial 1 (Tony)
As it was mentioned before, a large number of levels exist for such feature.
```{r}
contractRefDf$RATE_PLAN %>% unique %>% length
```
Now getting to know the different unique values for the `RATE_PLAN`
```{R}
contractRefDf$RATE_PLAN %>% unique
```
We can see that there are some similarities within some of those different values that would reflect the same info/value. For example, *2013 Business El Asly 30* and *2014 Business El Asly 30* are two different `RATE_PLAN` values that mainly reflect the same rate plan but for different years. Hence, one of the things to be done, is to discard the year value from the `RATE_PLAN`.
Also other numerical values were also excluded like the amount of GBs and the rate plan monetary value.
```{r}
contractRefDf$RATE_PLAN <- gsub("[2][0][0-9][0-9] ", "", contractRefDf$RATE_PLAN)
contractRefDf$RATE_PLAN <- gsub(" [0-9]+(\\.[0-9]*)* GB", "", contractRefDf$RATE_PLAN)
contractRefDf$RATE_PLAN <- gsub(" [0-9]+", "", contractRefDf$RATE_PLAN)
contractRefDf$RATE_PLAN <- as.factor(contractRefDf$RATE_PLAN)
```
Let's check now the number of `RATE_PLAN` levels.
```{r}
contractRefDf$RATE_PLAN %>% unique %>% length
```
As we can see, the impact was remarkable; as the `RATE_PLAN` levels dropped from 183 to 83 only.
However, adding it to the predictions, the score has decreased to `0.58943`. Hence, this approach has to be excluded for the moment until further feature engineering concerning the `RATE_PLAN` are applied.

##19- Analysing the `HANDSET_NAME` from `contractRefDf` and extracting some features from it to include in the predictions (Tony)
First, let's see the different possible values for the `HANDSET_NAME`.
```{r}
contractRefDf$HANDSET_NAME %>% unique %>% length
```
Let's see what those diffrent values are:
```{r}
contractRefDf$HANDSET_NAME %>% unique
```
Very huge possible values exist for the `HANDSET_NAME`.
Let's extract a handset category by merging different `HANDSET_NAME` values into categories that correspond to the manufacturer so that they relatively reflect a common behavior/usage of the handset device. So let's have a new column (attribute) to store this new feature `HANSET_CAT`, where the first occuring keyword in the `HANSET_NAME` is corresponding to such value/feature.
```{r}
contractRefDf <- contractRefDf %>% mutate(HANDSET_CAT = gsub(" (.)*$", "", HANDSET_NAME))
contractRefDf$HANDSET_CAT <- as.factor(contractRefDf$HANDSET_CAT)
```
The different possible values of this new attribute/feature has a remarkably fewer values from the `HANDSET_NAME`.
```{r}
contractRefDf$HANDSET_CAT %>% unique %>% length
```
Adding the `HANDSET_CAT` to the predicitions, we get a minimum score of `0.50000`. Hence, more feature engineering has to be done on this feature to obtain positive impact from it.

##20- Assuming that the `iPhone` users are the most likely to exceed their average usage (Tony)
Assuming that the different devices used have different data usage/consumption according to the firmware and other factors that may, added up to the personal customer's usage, reflect an intention to exceed the usage limit.
So let's extract a new parameter differentiating the `iPhone` users from the others:
```{r}
contractRefDf <- contractRefDf %>% mutate(iPhone = ifelse(grepl("iPhone", HANDSET_NAME), 1, 0))
```
Adding this feature to the predictions yields a score of `0.67081`, which is not an improvement. Hence, taking the used device into account for the predictions won't be considered for the moment.

##21- Adding a feature that reflects an increasing level of usage in the 5th month (Tony)
A new parameter was added depending on exceeding the average (mean) usage of the 4 months in the 5th one.
```{r}
trainRoamDf <- trainRoamDf %>% mutate(x = ifelse(mean(c(X206_USAGE, X207_USAGE, X208_USAGE, X209_USAGE)) < X210_USAGE, 1, 0))
testRoamDf <- testRoamDf %>% mutate(x = ifelse(mean(c(X206_USAGE, X207_USAGE, X208_USAGE, X209_USAGE)) < X210_USAGE, 1, 0))
```
Adding this new parameter to the predictions yields a score of `0.66639`, which is not an improvement.

##Analysing the `VALUE_SEGMENT` from `contract_ref` (Tony)
Let's check the unique values for the value segment:
```{r}
contractRefDf <- read.csv('data/contract_ref.csv')
contractRefDf$VALUE_SEGMENT %>% unique
```
As we can see, we have some NAs in addition to "N/A" values. So let's merge them together.
```{r}
contractRefDf$VALUE_SEGMENT[is.na(contractRefDf$VALUE_SEGMENT)] <- "N/A"
```
Let's check the distribution of the different values of the `VALUE_SEGMENT` among the customers in a descending order
```{r}
vs_frequencies <- contractRefDf %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY)) %>% arrange(desc(VS_frequency))
vs_frequencies
```
Let's plot the result showing the frequencies where the X-Axis is for the `VALUE_SEGMENT` and the Y-Axis is for the corresponding frequency `VS_frequency`:
```{r}
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

As we can see, almost half of the customers have a `VALUE_SEGMENT` of `Core`. It can be assumed that this is the default value untill some upgrade happens to classify the customer in a different higher category.
```{r}
contractRefDf[contractRefDf$VALUE_SEGMENT == "N/A",] %>% nrow
```
One of the problems we have here is that a considerable number of records have "N/A" values for the `VALUE_SEGMENT` (8175).

###Let's see if there's a relation between the `VALUE_SEGMENT` and the `RATE_PLAN` or not:
```{r}
contractRefDf %>% group_by(RATE_PLAN) %>% summarise(RT_frequency = length(CONTRACT_KEY)) %>% arrange(desc(RT_frequency))
```
The most frequent `RATE_PLAN` is the `Enterprise Shared Data Bundle`.
Let's check its relation with the `VALUE_SEGMENT`:

####Enterprise Shared Data Bundle
```{r}
vs_frequencies <- contractRefDf[contractRefDf$RATE_PLAN == "Enterprise Shared Data Bundle",] %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY))
vs_frequencies
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

The next most dominant rate plans are the following: `2013 Business El Asly 30`, `Business Flex 35`, `2014 ElAsly Plus 35`, and `Red 150`.
So let's check their corresponding relations with the `VALUE_SEGMENT`.

####2013 Business El Asly 30
```{r}
vs_frequencies <- contractRefDf[contractRefDf$RATE_PLAN == "2013 Business El Asly 30",] %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY))
vs_frequencies
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

####Business Flex 35
```{r}
vs_frequencies <- contractRefDf[contractRefDf$RATE_PLAN == "Business Flex 35",] %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY))
vs_frequencies
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

####2014 ElAsly Plus 35
```{r}
vs_frequencies <- contractRefDf[contractRefDf$RATE_PLAN == "2014 ElAsly Plus 35",] %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY))
vs_frequencies
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

####Red 150
```{r}
vs_frequencies <- contractRefDf[contractRefDf$RATE_PLAN == "Red 150",] %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY))
vs_frequencies
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

It is clear that there is a strong relation between the `RATE_PLAN` and the `VALUE_SEGMENT`.

##22- Cleaning the "N/A" values from the `VALUE_SEGMENT` and adding it to the predictions (Tony)
Let's infer the "N/A" values of the `VALUE_SEGMENT` through its relation with the `RATE_PLAN` by replacing the `VALUE_SEGMENT` having an "N/A" value with the dominant `VALUE_SEGMENT` value corresponding to the same `RATE_PLAN`. If it's still an "N/A" value, then take the second dominant one.
```{r}
dominant_value_segment <- function(rate_plan){
    vs_frequencies <- contractRefDf[contractRefDf$RATE_PLAN == rate_plan,] %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY)) %>% arrange(desc(VS_frequency))
    if(vs_frequencies$VALUE_SEGMENT[1] == "N/A"){
      result <- vs_frequencies$VALUE_SEGMENT[2]
    }
    else{
      result <- vs_frequencies$VALUE_SEGMENT[1]
    }
    return(result)
}

contractRefDf$VALUE_SEGMENT[contractRefDf$VALUE_SEGMENT == "N/A"] <- dominant_value_segment(contractRefDf$RATE_PLAN)
```
Let's see the new distribution of the `VALUE_SEGMENT` after getting rid of the "N/A" values.
```{r}
vs_frequencies <- contractRefDf %>% group_by(VALUE_SEGMENT) %>% summarise(VS_frequency = length(CONTRACT_KEY)) %>% arrange(desc(VS_frequency))
vs_frequencies
```
Let's plot the result showing the frequencies where the X-Axis is for the `VALUE_SEGMENT` and the Y-Axis is for the corresponding frequency `VS_frequency`:
```{r}
vs_frequencies %>% ggplot(aes(x=VALUE_SEGMENT, y=VS_frequency)) + geom_bar(stat='identity')
```

As we can see, almost half of the customers have a `VALUE_SEGMENT` of `Core` which is the dominant one.

Adding the `VALUE_SEGMENT` to the predicitons now yields a score of `0.63465`, which is not an improvement.

##23- Analysing and extracting new features from `RATE_PLAN` and adding it to the predictions - Trial 2 (Tony)
Let's try to extract the moneytary value from the `RATE_PLAN` and then include it in the predictions, in a new column/attribute `RATE_PLAN_VALUE`.

First, let's remove the year value:
```{r}
contractRefDf <- contractRefDf %>% mutate(RATE_PLAN_VALUE = gsub("[2][0][0-9][0-9] ", "", contractRefDf$RATE_PLAN))
```
Next, let's remove the GBs size of the plan:
```{r}
contractRefDf$RATE_PLAN_VALUE <- gsub(" [0-9]+(\\.[0-9]*)* GB", "", contractRefDf$RATE_PLAN_VALUE)
```
Now, any numberiacal value existing in the `RATE_PLAN` is the moneytary value we want.
So let's remove any other parts and just keep the number(s), and get the mean in case of multiple values (hybrid plans):
```{r}
contractRefDf$RATE_PLAN_VALUE <- gsub(" [a-zA-Z]+", "", contractRefDf$RATE_PLAN_VALUE)
contractRefDf$RATE_PLAN_VALUE <- gsub("[a-zA-Z]+ ", "", contractRefDf$RATE_PLAN_VALUE)
contractRefDf$RATE_PLAN_VALUE <- as.factor(contractRefDf$RATE_PLAN_VALUE)
```
Let's check now the number of `RATE_PLAN_VALUE` levels.
```{r}
contractRefDf$RATE_PLAN_VALUE %>% unique %>% length
```
Adding the `RATE_PLAN_VALUE` to the predicitions yields a score of `0.64236`.